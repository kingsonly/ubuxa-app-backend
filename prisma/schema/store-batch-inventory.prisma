// Store Batch Inventory Management
// This extends the store inventory system to track individual batches per store

model StoreBatchInventory {
  id        String    @id @default(auto()) @map("_id") @db.ObjectId
  
  // Store and inventory relationships
  store       Store     @relation(fields: [storeId], references: [id], onDelete: Cascade)
  storeId     String    @db.ObjectId
  inventory   Inventory @relation(fields: [inventoryId], references: [id], onDelete: Cascade)
  inventoryId String    @db.ObjectId
  
  // Batch relationship - this is the key addition
  inventoryBatch   InventoryBatch @relation(fields: [inventoryBatchId], references: [id], onDelete: Cascade)
  inventoryBatchId String         @db.ObjectId
  
  // Quantities for this specific batch in this store
  quantity           Int     @default(0)    // Current quantity of this batch in this store
  reservedQuantity   Int     @default(0)    // Reserved for pending transfers/sales
  allocatedQuantity  Int     @default(0)    // Originally allocated to this store
  
  // Batch allocation tracking
  allocationDate     DateTime @default(now()) // When this batch was allocated to the store
  expiryDate         DateTime?                // Batch expiry date (copied from batch for quick access)
  costPerUnit        Float?                   // Cost per unit for this batch (copied from batch)
  pricePerUnit       Float                    // Selling price per unit for this batch
  
  // Source tracking
  rootSourceStoreId  String  @db.ObjectId // Always main store where batch originated
  rootSourceStore    Store   @relation("BatchRootSource", fields: [rootSourceStoreId], references: [id], onDelete: NoAction)
  
  // Transfer tracking
  transferId         String?       @db.ObjectId // If this allocation came from a transfer
  sourceTransfer     StoreTransfer? @relation(fields: [transferId], references: [id], onDelete: SetNull)
  
  tenantId  String   @db.ObjectId
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: NoAction)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Ensure one record per store-inventory-batch combination
  @@unique([storeId, inventoryId, inventoryBatchId])
  @@map("store_batch_inventories")

  StoreBatchTransferInventory StoreBatchTransferInventory[]
}

// Enhanced Store Transfer to include batch information
model StoreBatchTransfer {
  id             String  @id @default(auto()) @map("_id") @db.ObjectId
  transferNumber String  @unique // Auto-generated transfer ID
  
  // Store relationships
  fromStore      Store   @relation("BatchTransferFrom", fields: [fromStoreId], references: [id], onDelete: NoAction)
  fromStoreId    String  @db.ObjectId
  toStore        Store   @relation("BatchTransferTo", fields: [toStoreId], references: [id], onDelete: NoAction)
  toStoreId      String  @db.ObjectId
  
  // Inventory and batch relationships
  inventory        Inventory      @relation("BatchTransferInventory", fields: [inventoryId], references: [id], onDelete: NoAction)
  inventoryId      String         @db.ObjectId
  inventoryBatch   InventoryBatch @relation("BatchTransferBatch", fields: [inventoryBatchId], references: [id], onDelete: NoAction)
  inventoryBatchId String         @db.ObjectId
  
  quantity       Int
  transferType   TransferType @default(DISTRIBUTION)
  status         TransferStatus @default(PENDING)
  
  // Batch-specific information
  batchCostPerUnit  Float?  // Cost per unit for this batch
  batchPricePerUnit Float   // Price per unit for this batch
  batchExpiryDate   DateTime? // Batch expiry date
  
  // Workflow tracking
  requestId      String?  @db.ObjectId // If initiated by request
  request        StoreBatchRequest? @relation(fields: [requestId], references: [id], onDelete: SetNull)
  
  initiatedBy    String   @db.ObjectId // User who initiated
  initiator      User     @relation("BatchTransferInitiator", fields: [initiatedBy], references: [id], onDelete: NoAction)
  
  approvedBy     String?  @db.ObjectId // User who approved (if required)
  approver       User?    @relation("BatchTransferApprover", fields: [approvedBy], references: [id], onDelete: NoAction)
  
  completedBy    String?  @db.ObjectId // User who marked as completed
  completer      User?    @relation("BatchTransferCompleter", fields: [completedBy], references: [id], onDelete: NoAction)
  
  notes          String?
  rejectionReason String?
  
  tenantId       String   @db.ObjectId
  tenant         Tenant   @relation(fields: [tenantId], references: [id], onDelete: NoAction)
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  approvedAt     DateTime?
  completedAt    DateTime?
  rejectedAt     DateTime?
  
  @@map("store_batch_transfers")
  StoreBatchTransferInventory StoreBatchTransferInventory[]
}

// Enhanced Store Request to include batch preferences
model StoreBatchRequest {
  id             String  @id @default(auto()) @map("_id") @db.ObjectId
  requestNumber  String  @unique // Auto-generated request ID
  
  fromStore      Store   @relation("BatchRequestFrom", fields: [fromStoreId], references: [id], onDelete: NoAction)
  fromStoreId    String  @db.ObjectId // Store requesting inventory
  toStore        Store   @relation("BatchRequestTo", fields: [toStoreId], references: [id], onDelete: NoAction)
  toStoreId      String  @db.ObjectId // Store being requested from
  
  inventory      Inventory @relation("BatchRequestInventory", fields: [inventoryId], references: [id], onDelete: NoAction)
  inventoryId    String    @db.ObjectId
  
  // Batch preferences (optional - if not specified, system will auto-allocate)
  preferredBatchId String?        @db.ObjectId // Specific batch requested
  preferredBatch   InventoryBatch? @relation(fields: [preferredBatchId], references: [id], onDelete: SetNull)
  
  // Batch selection criteria
  preferOldestBatch   Boolean @default(true)  // FIFO preference
  preferNewestBatch   Boolean @default(false) // LIFO preference
  maxAcceptablePrice  Float?                  // Maximum price per unit acceptable
  minExpiryDate       DateTime?               // Minimum expiry date acceptable
  
  requestedQuantity Int
  approvedQuantity  Int?    // May be different from requested
  
  status         RequestStatus @default(PENDING)
  priority       RequestPriority @default(NORMAL)
  
  requestedBy    String   @db.ObjectId // User who made the request
  requester      User     @relation("StoreBatchRequester", fields: [requestedBy], references: [id], onDelete: NoAction)
  
  reviewedBy     String?  @db.ObjectId // User who reviewed the request
  reviewer       User?    @relation("StoreBatchRequestReviewer", fields: [reviewedBy], references: [id], onDelete: NoAction)
  
  justification  String?  // Why the inventory is needed
  notes          String?  // Additional notes
  rejectionReason String? // Reason for rejection
  
  // Expected delivery
  expectedDate   DateTime?
  
  tenantId       String   @db.ObjectId
  tenant         Tenant   @relation(fields: [tenantId], references: [id], onDelete: NoAction)
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  reviewedAt     DateTime?
  
  // Related transfers
  transfers      StoreBatchTransfer[]
  
  @@map("store_batch_requests")
}


model StoreBatchTransferInventory {
  id                    String              @id @default(auto()) @map("_id") @db.ObjectId
  storeBatchTransferId  String              @db.ObjectId
  storeBatchInventoryId String              @db.ObjectId

  storeBatchTransfer    StoreBatchTransfer  @relation(fields: [storeBatchTransferId], references: [id], onDelete: Cascade)
  storeBatchInventory   StoreBatchInventory @relation(fields: [storeBatchInventoryId], references: [id], onDelete: Cascade)

  tenantId String  @db.ObjectId
  tenant   Tenant  @relation(fields: [tenantId], references: [id], onDelete: NoAction)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([storeBatchTransferId, storeBatchInventoryId])
  @@map("store_batch_transfer_inventories")
}
